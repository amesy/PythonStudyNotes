[TOC]

# python函数

## 函数 

> 函数：可以实现一些特定功能的小方法或是小程序。 
>
> python函数: 完成一定的功能,由若干语句组成的语句块, 函数名称, 参数列表构成, 它是组织代码的最小单位。

**作用** 

> 结构化变成对代码的最基本的封装, 一般按照功能组织一段代码。 
>
> 封装的目的为了复用, 减少冗余代码。 
>
> 代码更加简洁美观,可读易懂。

**总结**

> 函数是可调用的对象,callable()。 

### 函数参数 

1、参数调用时传入的参数要和定义的个数相匹配。 

2、位置参数：按照参数定义顺序传入实参。 

3、关键字参数: 使用形参的名字来传入实参的方式,如果使用了形参名字,那么传参顺序就可以和定义顺序不同。

注: **参数列表参数一般顺序是,普通参数,缺省参数,可变位置参数,keyword-only参数(可带缺省值),可变关键字参数.**

### 函数参数默认值 

> 参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值。
>
> 参数非常多时,并不需要用户每次都输入所有的参数,简化函数调用。 

### 可变参数 

**可变参数分为位置可变参数和关键字可变参数。**

> 一个形参可以匹配任意个参数。 
>
> 在形参前使用 ` *` 表示该形参是可变参数,可以接收多个实参。
> 收集多个实参为一个**元组**。
>
> ```python 
> def func(*形参)：  
> 	pass  
> func(实参) 
> ```

**关键字参数的可变参数**

> 形参前使用 `**` 符号,表示可以接收多个关键字参数。 
>
> 收集的实参名称和值组成一个**字典**。

**可变参数混合使用** 

> 混合使用参数时,可变参数要放在参数列表的最后,普通参数需要放到参数列表前面,位置可变参数需要放在关键字可变参数之前。
>
> ```python 
> def showconfig(username,password,**kwargs) 
> def showconfig(username,*args,**kwargs)
> def showconfig(username,password,**kwargs,*args)
> ```

### keyword-only参数

注: python3.x 新加入。

> 在一个带星号的参数后, 或者一个位置可变参数后, 出现的普通参数即 keyword-only 参数。
>
> ```python 
> # 例 
> def fn(*,x,y): 
>     pass  
> fn(x=4, y=5)
> ```

### 参数解构

> 给函数提供实参时,可在集群类型前使用*或**,把集群类型的元素解开,提取出所有元素作为函数的实参。
>
> 非字典类型使用 `*` 解构成位置参数。
>
> 字典类型使用 `**` 解构成关键字参数。
>
> 提取出来的元素数目要和参数的要匹配, 也要和参数的类型匹配。

```python 
In [1]: import random

In [2]: def double_values(*nums):
   ...:     print(nums)
   ...:     return max(nums), min(nums)
   ...:

In [3]: print(*double_values(*[random.randint(10, 20) for _ in range(10)]))  # 两次解构.
(15, 12, 15, 13, 20, 11, 13, 20, 18, 13)
20 11

In [4]:
```



## 插入排序



## 函数的返回值, 作用域 

### 函数返回值 

> 作用: 结束函数调用和返回返回值。
>
> `返回值` 使用return语句返回。 
>
> 所有函数都有函数值,如果没有 return 语句,隐式调用 `return None`。 
>
> 一个函数可以存在多个return语句, 但是只有一条可以被执行。
>
> 如果函数执行了return语句,函数就会返回,当前被执行的return语句之后的其他语句就不会被执行。

### 函数嵌套 

> 函数有可见范围,这就是 `作用域` 的概念。
> 内部函数不能被外部直接使用,会抛异常 NameError 。

### 函数作用域

> 作用域: 一个标识符的可见范围即标识符的作用域.一般常说的是变量的作用域。 
>
> - 全局作用域: 在整个程序运行环境中都可见。 
>
> - 局部作用域: 在函数, 类等内部可见。 
>
>   局部变量使用范围不能超过其所在的局部作用域。
>
>   如果是多层函数嵌套，外层变量作用域在内层作用域可见。 

**global - 全局变量**  

> 使用 global 关键字的变量, 将函数内部的变量声明为函数外的全局作用域中的变量。
>
> 如果全局作用域中没有该局部作用域定义的变量，使用global后，相当于在全局作用域中定义且赋值了一个变量对应的值。如果全局作用域中已有该变量，则会覆盖。
>
> global使用原则: 
>
> - 外部作用域变量在内部作用域可见, 但也不要在这个内部的局部作用域中直接使用, 因为函数的目的就是为了封装, 尽量与外界隔离。
> - 如果函数需要使用外部全局变量, 使用函数的形参传参解决。

### 闭包 

> 自由变量: 未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量。
> 闭包: 是一个概念, 出现在嵌套函数中, **内层函数引用到外层函数的自由变量**, 就形成了闭包, JS就是如此。 

示例: 

```python 
In [1]: def func1():
    ...:     count = 0
    ...:     def inc1():
    ...:         count += 1  # 该处报错问题, 使用global可以解决,但这样使用的是全局变量,而不是闭包。 
    ...:         return count
    ...:     return inc
    ...:

In [2]: 
```

该counter函数会报错 `UnboundLocalError` 。

```python 
In [3]: def func2():
   ...:     count = [0]
   ...:     def inc2():
   ...:         count[0] += 1  # 该处的使用方式为count的元素修改值,而不是重新定义变量。 
   ...:         return count[0]
   ...:     return inc
    
In [4]:
```

该counter函数不会报错。

**总结** 

> 1、内部函数，不修改全局变量可以访问全局变量；在内部函数里面修改同名全局变量，则python会认为该变量就是一个局部变量；在内部函数修改同名全局变量之前调用变量名称，则引发 `UnboundLocalError`。
>
> 2、在程序中设置的 count 属于全局变量, 而在嵌套函数中没有 count 的定义,根据python访问局部变量和全局变量的规则：当搜索一个变量的时候，python先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，python就在全局变量中找这个变量，如果找不到抛出异常(NameError或者UnboundLocalError，这取决于python版本。) 
>
> 3、如果内部函数有引用外部函数的同名变量或者全局变量, 并且对这个变量有修改, 那么python会认为它是一个局部变量,又因为函数中没有 count 的定义和赋值, 所以报错。

### nonlocal 关键字

> 用来在函数或其他作用域中使用外层(非全局)变量。
>
> 使用了nonlocal关键字, 即把变量标记为在上级的局部作用域中定义的变量, 但不能是全局作用域中定义的.

```python 
In [1]: def counter():
   ...:     count = 0
   ...:     def inc():
   ...:         nonlocal count
   ...:         count += 1
   ...:         return count
   ...:     return inc
   ...:

In [2]: res = counter()

In [3]: res()
Out[3]: 1

In [4]: res()  # 变量count的值伴随着这个函数对象的整个生命周期。
Out[4]: 2

In [5]:
```

### 默认值的作用域 

示例1： 

```python 
In [1]: def foo(lst=[]):
   ...:     lst.append(1)
   ...:     return lst
   ...:

In [2]: foo.__defaults__
Out[2]: ([],)

In [3]: foo()
Out[3]: [1]

In [4]: foo.__defaults__
Out[4]: ([1],)

In [5]: foo()
Out[5]: [1, 1]

In [6]: foo.__defaults__
Out[6]: ([1, 1],)
# 函数也是对象,python把函数的默认值放在了属性中,这个属性就伴随着这个函数对象的整个生命周期。
```

示例2：引用类型

```python 
In [7]: def foo(xyz=[], u='abc', z=123):
    ...:     xyz.append(1)
    ...:     return xyz
    ...:

In [8]: foo(), id(foo)
Out[8]: ([1], 2239176151928)

In [9]: foo.__defaults__
Out[9]: ([1], 'abc', 123)

In [10]: foo(), id(foo)
Out[10]: ([1, 1], 2239176151928)

In [11]: foo.__defaults__
Out[11]: ([1, 1], 'abc', 123)

In [12]:
# 函数地址并没有变,即函数这个对象的地址没有变,调用它,它的属性__defaults__中使用元组保存所有默认值. 
# xyz默认值是引用类型,引用类型的元素变动,并不是元组的变化。 
```

示例3：非引用类型

```python 
In [1]: def foo(w,u='abc',z=123):
   ...:     u='xyz'
   ...:     z=789
   ...:     print(w,u,z)
   ...:

In [2]: foo.__defaults__
Out[2]: ('abc', 123)

In [3]: foo('amesy')
amesy xyz 789

In [4]: foo.__defaults__
Out[4]: ('abc', 123)

# 属性__defaults__中使用元组保存所有默认值,__defaults__不会因为在函数体内使用了它而发生改变。 
# 可变类型默认值,如果使用默认值,就可能修改这个默认值。
# 有时候这个特性是好的,有时候不然,有副作用。
```

示例4：按需改变

```python 
def foo(xyz=[], u='abc', z=123):
	xyz = xyz[:] # 影子拷贝.
	xyz.append(1)
	print(xyz)

# 使用影子拷贝创建一个新的对象,永远不能改变传入的参数。
```

```python 
def foo(xyz=None, u='abc', z=123):
    if xyz is None:
        xyz = []
    xyz.append(1)
    print(xyz)
    
# 通过值的判断就可以灵活的选择创建或修改传入对象。 
# 这种方式灵活,应用广泛。很多函数的定义,都会使用None这个不可变的值作为默认参数,算是一种惯用法。
```

### 变量名解析原则LEGB

- Local, 即本地作用域, 局部作用域的local命名空间。函数调用时创建, 调用结束消亡。 
- Enclosing, python2.2时引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间。 
- Global, 全局作用域, 即一个模块的命名空间。模块被import时创建, 解释器退出时消亡。 
- Build-in, 内置模块的命名空间, 生命周期从python解释器启动时创建到解释器退出时消亡。
  - 例如print(open),print和open都是内置的变量. 

   所以一个名词的查找顺序就是 `LEGB` 。

   图示:

  ​	![LEGB](http://static.open-open.com/lib/uploadImg/20150209/20150209125753_178.jpg)

### 函数的销毁

全局函数销毁: 

- 重新定义同名函数。 
- del语句删除函数对象。
- 程序结束时自然消亡。 

局部函数销毁: 

- 重新在上级作用域定义同名函数。


- del语句删除函数对象。
- 上级作用域销毁时。

## 树 



## 函数代码的执行流程 

> 函数的执行总是从程序的第一行代码开始的，从上到下，从左到右，从第一条语句开始按顺序依次执行。
>
> 函数定义并不会改变程序的执行流程，但应该注意函数代码块中的语句并不是立即就执行的，而是等到函数被程序调用时才会执行。
>
> 函数调用可以看作程序执行流程中的一个迂回路径，遇到函数调用时，并不会直接继续执行下一条语句，而是跳到函数体的第一行，继续执行完函数代码块的所有语句，再跳回到原来离开的地方。
>
> 函数代码块中也可以调用其他函数，当程序流程运行到一个函数之中时，可能需要执行其他函数中的语句; 但当执行那个函数中的语句时，又可能再需要调用执行另一个函数的语句。
>
> Python对于它运行到哪里有记录，所以在每个函数执行结束之后，程序都能跳回到它离开的那个地方, 直至执行到整个程序的结尾，才会结束程序。
>

动态演示函数的执行过程: <http://pythontutor.com/visualize.html#mode=edit>

## 递归函数 

> ​    函数直接或间接调用自身即递归。
>
> ​    递归需要有边界条件,递归前进段, 递归返回段。 
>

递归动态图示:  http://codingpy.com/article/10-gifs-to-understand-some-programming-concepts/

示例：斐波那契数列 

```python 
# 如果设F(n)为该数列的第n项,(n∈N-1),那么这句话可以写成:F(n) = F(n-1) + F(n-2) 
def fn(n): 
    return 1 if n < 2 else fn(n-1) + fn(n-2) 
```

实例: 阶乘的递归 

```python 
def fn(n): 
	if n == 0:
		raise ValueError('0 is invaild') 
	elif n == 1: 
		return 1
	return n * fn(n-1)
```

注: 

- 递归一定要有退出条件,递归调用一定要执行到这个退出条件；没有退出条件的递归调用就是无限调用。
- python对递归调用的深度做了限制, 超过递归深度限制, 会抛异常。`sys.getrecursionlimit() `

**递归函数的性能**

- 深度越深, 效率越低。
- 递归有深度限制, 如果递归复杂, 函数反复压栈, 栈内存很快就溢出了。  

示例：对斐波那契数列的改进 

```python 
pre = 0
cur = 1
def fib(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib(n-1, pre, cur)
```

**间接递归** 

> 通过别的函数调用了函数自身, 即间接递归。 
> 在复杂代码情况下发生间接递归调用是非常危险的, 要用代码规范来避免这种递归调用的发生。 

**总结** 

递归是一种很自然的表达,符合逻辑思维。
递归相对运行效率低,每一次调用函数都要开辟栈帧。
递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了。
如果是有限次数的递归,可以使用递归调用,或者使用循环代替,循环代码稍微要复杂一些,但是只要不是死循环,可以多次迭代直至算出结果。
绝大多数递归,都可以使用循环实现。
即使递归代码很简洁,但是能不用递归就不要用。

## 高阶函数

> 概念: 把函数当成参数传递的一种函数。 
>
> 满足要求: 接收一个或多个函数作为参数，输出一个函数。(两者满足其一即可)

示例： 

```python 
In [1]: def add(x, y, func):
   ...:     return func(x) + func(y)
   ...:

In [2]: add(-8, 11, abs)
Out[2]: 19
```

示例: 计数器 

```python 
In [9]: def counter(base):
   ...:     def inc(step=1):
   ...:         nonlocal base  # 该行没有的话会报错。
   ...:         base += step
   ...:         return base
   ...:     return inc
   ...:

In [10]: print(counter(5)())
6
In [11]:
```

分析: 

- 该 counter 是一个高阶函数,  第4行base被重新赋值, 所以需要nonlocal关键字。 
- 对于 `f1 = counter(5)` 和 `f2 = counter(5)` , 值相同但内存地址不同。因为 inc 是 counter内的函数, 每次调用counter时, inc都要在栈上重新生成, 故内存地址不相等。


示例: 自定义 sort 函数 

>   排序问题: 仿照内建函数sorted, 实现一个sort函数(不使用内建函数), 且能够为列表元素排序。 
>   思路: 
>
>   -   内建函数sorted会返回一个新的列表,可以设置升序或降序,设置的排序的函数,自定义的sort函数也要实现这个功能。
>   -   新建一个列表, 遍历原列表, 和新列表的值依次比较决定如何插入到新列表中。 

```python 
def sort(iterable, reverse=False):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            bol = x > y if reverse else x < y
            if bol:
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst, reverse=True))
```

```python 
def sort(iterable, fn = lambda x, y: x < y):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            if fn(x, y):
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst))
```








## 匿名函数 

> 匿名函数,即没有名字的函数。 
>
> python借助 lambda 表达式构建匿名函数；它只能写在一行上,被称为单行函数。
>
> 格式:  `lambda 参数列表: 表达式 `
>
> - 参数列表不需要小括号。
> - 冒号用来分割参数列表和表达式。
> - 不需要使用return,表达式的值,就是匿名函数返回值. 
> - lambda表达式(匿名函数)只能写在一行上,被称为单行函数. 

```python 
In [4]: print((lambda x, *, y=30: x + y)(5, y=10))
15

In [5]: print((lambda *args: (x for x in args))(*range(5)))
<generator object <lambda>.<locals>.<genexpr> at 0x000001E699027888>

In [6]: print((lambda *args: [x for x in args])(*range(5)))
[0, 1, 2, 3, 4]

In [9]: print((lambda *args: {x for x in args})(*range(5)))
{0, 1, 2, 3, 4}
```

## map()函数 

> python内置的一个高阶函数, 它接收一个函数和一个列表, 并且把列表的元素以此传递给该函数，然后返回一个该函数处理完所有列表元素的迭代器。

```python 
In [11]: list(map(lambda x: x**2, [1, 2, 3, 4]))
Out[11]: [1, 4, 9, 16]

In [12]:
```

示例: 在高阶函数传参时,使用lambda表达式, 简化代码。

```python
In [14]: [x for x in (lambda *args: map(lambda x: x**2, args))(*range(5))]
Out[14]: [0, 1, 4, 9, 16]
```

```python
In [15]: [x for x in (lambda *args: map(lambda x: (x+1,args), args))(*range(5))]
Out[15]:
[(1, (0, 1, 2, 3, 4)),
 (2, (0, 1, 2, 3, 4)),
 (3, (0, 1, 2, 3, 4)),
 (4, (0, 1, 2, 3, 4)),
 (5, (0, 1, 2, 3, 4))]
```

## filter()函数

>   python内置的高阶函数, 过滤可迭代对象的元素, 返回一个迭代器。用法和map函数类似。 

```python 
In [1]: list(filter(lambda x: x %3 == 0, [0, 3, 4, 7, 9]))
Out[1]: [0, 3, 9]

In [2]:
```

## 柯里化Currying 

>   指将原来接收两个参数的函数变成新的接收一个参数的函数的过程, 新的函数返回一个以原有第二个参数为参数的函数。  
>   即 `z = f(x, y)` 转换成 `z = f(x)(y)` 的形式。  

示例: 通过嵌套函数就可以把函数转换为柯里化函数。

```python 
def add(x, y):
    return x + y

print(add(5, 4))
 
# 以上代码通过柯里化, 改为如下: 
def add(x):
    def _add(y):
        return x + y
    return _add

print(add(5)(4))
```

# 生成器 

- 带有 **yield** 关键字的的函数在 Python 中被称之为 generator(生成器)。Python 解释器会将带有 **yield** 关键字的函数视为一个 generator 来处理。一个函数或者子程序都只能 return 一次，但是一个生成器能暂停执行并返回一个中间的结果 —— 这就是 yield 语句的功能 : 返回一个中间值给调用者并暂停执行。
- **生成器其实是一种特殊的迭代器**，这句话反过来不成立。不过这种迭代器更加优雅, 它不需要再像上面的类一样写 `__iter__()`和 `__next__()`方法了，只需要一个 `yiled`关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。



```python 
# generator
def arr(num):
    n, a, b = 0, 0, 1
    while n < num:
        yield b
        a, b = b, a+b
        n += 1
res = arr(5)
for _ in range(5):
    print(next(res))
```

**分析：生成器 arr() 的执行过程**

- 执行语句 res = arr(5) 时，并不会马上执行 arr() 函数的代码块，而是首先返回一个 iterable 对象。
- 在 for 循环语句执行时，才会执行 fab() 函数的代码块。 
- 执行到语句 yield b 时，fab() 函数会返回一个迭代值，直到下次迭代前，程序流会回到 yield b 的下一条语句继续执行，然后再次回到 for 循环，如此迭代直到结束。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 
- 由此可以看出，**生成器通过关键字 yield 不断的将迭代器返回到内存进行处理，而不会一次性的将对象全部放入内存，从而节省内存空间**。从这点看来生成器和迭代器非常相似，但如果更深入的了解的话，其实两者仍存在区别。

## 生成器函数 

> 函数体中包含yield语句的函数,返回生成器对象. 
>
> - 生成器对象,是一个可迭代对象, 也是一个迭代器。
> - 生成器对象,是延迟计算,惰性求值的。
>
> 生成器函数等价于生成器表达式,只不过生成器函数可以更加的复杂。
>
> 在一个生成器函数中, 如果没有 return, 则默认执行至函数完毕, 如果在执行过程中 return, 则会直接抛出 `StopIteration` 来终止迭代。

判断一个函数是否为generator函数, 使用isgeneratorfunction判断。

```python 
In [1]: def func(b):
    ...:     yield b
    ...:
    ...:

In [2]: from inspect import isgeneratorfunction

In [3]: isgeneratorfunction(func)
Out[3]: True
```

**注意区分 func 和 func(b)** ，`func` 是一个 generator function，而 `func(b)` 是调用 fab 返回的一个 generator。 

```python 
In [4]: from collections import Iterable

In [5]: isinstance(func, Iterable)
Out[5]: False

In [6]: isinstance(func(4), Iterable)
Out[6]: True

In [7]: 
```

示例: 处理递归问题。

```python  
def fib():
    x = 1
    y = 1
    while True:
        yield x
        x, y = y, x+y
foo = fib()
for _ in range(10):
    print(next(foo))
```

```python 
pre = 0
cur = 1
print(pre, cur, end = ' ')

def fib1(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib1(n-1, pre, cur)
    
fib1(10)
```

## 生成器表达式 

> 生成器表达式是列表解析的扩展，就如上所述：生成器是一个特定的函数, 允许返回一个中间值，然后挂起代码的执行，稍后再恢复执行。列表解析的不足在于，它必须一次性生成所有的数据，用以创建列表对象，所以不适用于迭代大量的数据。 **生成器表达式则通过结合列表解析和生成器来解决这个问题。**

**语法** 

```python 
# 列表解析式 
[expr for iter_var in iterable if cond_expr] 

# 生成器表达式 
(expr for iter_var in iterable if cond_expr)
```

**总结** 

> 两者的语法非常相似，但生成器表达式返回的不是一个列表类型对象，而是一个生成器对象，生成器是一个内存使用友好的结构。在需要迭代一个对象时，应该优先考虑使用生成器替代迭代器，使用生成器表达式替代列表解析。当然这并不是绝对的。迭代器和生成器是 Python 很重要的特性，对其有很好的理解能够写出更加 Pythonic 的代码。

## 协程coroutine: 

> 属于生成器的高级用法。 
>
> 比进程,线程轻量级。 
>
> 是在用户空间调度函数的一种实现。 
>
> python3 asyncio 就是协程实现,已经加入到标准库。
>
> python3.5使用 `async`, `await` 关键字直接原生支持协程。 

**协程调度实现思路**

>   有2个生成器A, B, next(A)后,A执行到yield语句暂停, 然后执行next(B), B执行到yield语句也暂停, 就再次调用next(A), 然后再调用next(B), 周而复始, 就实现了调度的效果。 

- 可以引入调度的策略来实现切换的方式。 
- 协程是一种非抢占式调度。
- 另一个 yield 的例子来源于文件读取。如果直接对文件对象调用 read() 方法, 会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。
- 通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取。

```python
def read_file(fpath):
   BLOCK_SIZE = 1024
   with open(fpath, 'rb') as f:
       while True:
           block = f.read(BLOCK_SIZE)
           if block:
               yield block
           else:
               return 
```

### yield from 

>   `yield from` 是 python3.3 出现的新的语法。
>
>    `yield from iterable` 是 `for item in iterable: yield item` 形式的语法糖。

```python 
def inc():
    for x in range(10):
        yield x

# 等价于

def inc():
    yield from range(10)

foo = inc()
for _ in range(10):
    print(next(foo))
```

# 装饰器 

## 无参装饰器 

```python 
def add(x, y):
    return x+y

def func(fn, *args, **kwargs):
    print('begin')
    res = fn(*args, **kwargs)
    print('end')
    return res

print(func(add, 4, y=5))
```

## 装饰器语法糖

>   装饰器(无参)：
>
>   -   是一个函数; 
>   -   函数作为它的形参; 
>   -   返回值也是一个函数; 
>   -   使用 `@FunctionName` 方式, 简化调用; 
>   -   可以使用特殊属性 `__name__` 查看函数名。
>
>   装饰器和高阶函数：
>
>   -   装饰器是高阶函数, 但装饰器是对传入函数的功能的装饰(即功能增强). 

```python 
import datetime
import time

def logger(fn):
    def wrap(*args, **kwargs):
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)
    return wrap

@logger  # add = logger(add)

def add(x, y):
    time.sleep(1)
    return x + y

print(add(4, 5))
```

## 文档字符串

>   在函数语句块的第一行, 且习惯是多行的文本, 一般使用三引号。   
>
>   惯例是首字母大写, 第一行写概述, 然后空一行, 第三行写详细描述。 
>
>   可以使用特殊属性 `__doc__` 访问这个文档。 

```python 
def add(x, y):
    """ This is a function addition"""
    return x + y

print('result: {}, function_name: {}, Document_desc: {}'.format(add(4, 5), add.__name__, add.__doc__)
```

```python
import datetime
import time

def copy_properties(src, dst):
    dst.__name__ = src.__name__
    dst.__doc__ = src.__doc__

def logger(fn):
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    copy_properties(fn, wrap)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

上面的函数, 如果没有 `copy_properties`，原函数 `add`对象的属性都会被替换成 `wrap` ; 因此提供 `copy_properties`函数, 被封装函数属性 –> copy -> 包装函数属性。通过 `copy_properties` 函数用被包装函数的属性覆盖掉包装函数。凡是被装饰的函数都需要复制这些属性, 这个函数很通用, 可以将复制属性的函数构建成装饰器函数, 带参装饰器。 

## 带参装饰器 

>   它是一个函数, 函数作为它的形参。返回值是一个不带参的装饰器函数, 使用 `@functionname (参数列表)` 方式调用。可以看做在装饰器外层又加了一层函数. 

示例: 将记录的功能提取出来,就可以通过外部提供的函数来灵活控制输出。

```python 
import datetime
import time

def copy_properties(src):
    def _copy(dst):
        dst.__name__ = src.__name__
        dst.__doc__ = src.__doc__
        return dst
    return _copy

def logger(fn):
    @copy_properties(fn)
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

# functools模块

>   Python自带的 `functools` 模块提供了一些常用的高阶函数，也就是用于处理其它函数的特殊函数。换言之，就是能使用该模块对可调用对象进行处理。

## update_wrapper()

该函数用于更新包装函数（wrapper），使它看起来像原函数一样, 类似于上面代码中的 `copy_properties` 。该函数主要用在装饰器函数的定义中，置于包装函数之前。如果没有对包装函数进行更新，那么被装饰后的函数所具有的元信息就会变为包装函数的元信息，而不是原函数的元信息。

```python 
# 语法 
update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)) 
```

可选的参数是一个元组，`assigned` 元组指定要直接使用原函数的值进行替换的属性，`updated` 元组指定要对照原函数进行更新的属性。这两个参数的默认值分别是模块级别的常量：`WRAPPER_ASSIGNMENTS` 和 `WRAPPER_UPDATES`。前者指定了对包装函数的 `__name__`, `__module__`, `__doc__` 属性直接赋值，而后者指定了对包装函数的 `__dict__` 属性进行更新。

示例：属性复制.

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return functools.update_wrapper(wrapper, fn)  # 复制函数属性, 功能类似functools.wraps.
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__, add.__wrapped__, add.__dict__, sep='\n')  
```

## partial()

```python 
# 语法
partial(func, *args, **keywords)
```

-   该函数返回一个 partial 对象, 调用该对象的效果相当于调用 func 函数, 并传入位置参数 args 和关键字参数 keywords 。如果调用该对象时传入了位置参数，则这些参数会被添加到 args 中。如果传入了关键字参数，则会被添加到 keywords 中。 
-   也称偏函数, 把函数部分的参数固定下来, 相当于为部分的参数添加了一个固定的默认值, 形成一个新的函数并返回, 从partial生成的函数, 是对原函数的封装。

示例： 

```python 
import functools

def add(x, y, *args) -> int:
    print(args)
    return x + y

newadd = functools.partial(add, 1,3,6,5)
print(newadd(7))
print(newadd(7, 10))
# print(newadd(9, 10, y=20, x=26))  # 报错.
print(newadd())
```

## wraps()

```python 
# 语法 
functools.wraps(wrapped[, assigned][, updated])
```

`wraps()` 简化了 `update_wrapper()` 函数的调用。

它等价于 `partial(update_wrapper, wrapped=wrapped, assigned, updated=updated)`。

示例： 

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        @functools.wraps(fn)  # 属性复制.
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return wrapper
        # return functools.update_wrapper(wrapper, fn)
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__,add.__dict__, sep='\n')
```

## functools.lru_cache()

```python 
# 语法 
lru_cache(maxsize=128, typed=False)
```

>   `least-recently-used` 装饰器。 lru即最近最少使用，cache即缓存。 
>
>   如果 maxsize 设置为None, 则禁用 LRU 功能, 并且缓存可无限制增长, 当 maxsize 是2的幂的时候, LRU 功能执行得最好。  
>
>   如果 typed 设置为 True , 则不同类型的函数参数将单独缓存。例: f(3) 和 f(3.0) 将被视为具有不同结果的不同调用。

示例：斐波那契数列递归方法的改造. 

```python 
import functools

@functools.lru_cache()  # 最大限度缓存.
def fn(n):
    if n < 2:
        return n
    return fn(n-1) + fn(n-2)

print([fn(x) for x in range(100)])
```

**lru_cache装饰器应用**

>   使用前提： 
>
>   -   同样的函数参数一定得到同样的结果；
>   -   函数执行时间很长,且要多次执行。
>
>   本质是函数调用的参数 -> 返回值. 
>
>   缺点： 
>
>   -   不支持缓存过期,key无法过期 失效。
>   -   不支持清除操作。
>   -   不支持分布式,是一个单机的缓存。
>
>   适用场景, 单机上需要空间换时间的地方,可以用缓存来将计算变成快速的查询。

# 参数注解 

>   python是动态语言, 变量随时可以被赋值, 且能赋值为不同的类型; 它也不是静态编译型语言, 变量类型是在运行时决定的;  
>
>   动态语言很灵活, 但是也有弊端：  
>
>   -   难发现: 由于不做任何类型检查, 直到运行期问题才显现出来, 或者线上运行时才会暴露出问题; 
>   -   难使用: 函数的使用者看到函数的时候, 并不知道你的函数设计,不知道应该传入什么类型的数据. 
>
>   解决这种动态语言定义的弊端:   
>
>   -   增加文档Documentation String.  (`__doc__`) 
>   -   惯例, 非强制标准。 
>   -   函数定义更新与文档更新未必同步。

**函数注解**

>   python3.5引入。 
>
>   对函数的参数进行类型注解。 
>
>   只对函数参数做一个辅助说明, 并不对函数参数进行类型检查。 
>
>   提供第三方工具, 做代码分析, 发现隐藏的BUG。 
>
>   函数注解信息,保存在 __annotations__属性中. 

**变量注解** 

>   python3.6引入。 
>
>   示例：i:int = 3 

示例: 

```python 
In [1]: def func(x:int, y:int) -> int:
   ...:     return x+y
   ...:

In [2]: func.__annotations__
Out[2]: {'return': int, 'x': int, 'y': int}

In [3]:
```

**应用场合** 

-   函数参数类型检查。 

-   思路： 

    -   函数参数的检查,一定是在函数外。

    -   函数应该作为参数,传入到检查函数中。  

    -   检查函数拿到函数传入的实际参数,与形参声明对比。 

    -   `__annotations__` 属性是一个字典,其中包括返回值类型的声明。

        假设要做位置参数的判断, 无法和字典中的声明对应, 使用 `inspect` 模块。

# inspect模块:

>   提供获取对象信息的函数,可以检查函数和类、类型检查。

## signature(callable) 

>   获取函数签名, 函数签名包含了一个函数的信息, 包括函数名,它的参数类型,类和名称空间及其他信息。

```python 
In [1]: import inspect

In [2]: def add(x:int, y:int, *args, **kwargs) -> int:
   ...:     return x + y
   ...:

In [3]: sig = inspect.signature(add)

In [4]: sig
Out[4]: <Signature (x:int, y:int, *args, **kwargs) -> int>

In [5]: sig.parameters
Out[5]:
mappingproxy({'args': <Parameter "*args">,
              'kwargs': <Parameter "**kwargs">,
              'x': <Parameter "x:int">,
              'y': <Parameter "y:int">})

In [6]: sig.return_annotation
Out[6]: int

In [7]: sig.parameters['y']
Out[7]: <Parameter "y:int">

In [8]: sig.parameters['y'].annotation
Out[8]: int

In [9]: sig.parameters['args'].annotation
Out[9]: inspect._empty

In [10]:
```

与 inspect模块相关的一些 is 函数：  

```python 
inspect.isfunction(add), 是否是函数; 
isspect.ismethod(add), 是否是类的方法; 
inspect.isgenerator(add), 是否是生成器对象; 
inspect.isgeneratorfunction(add), 是否是生成器函数; 
inspect.isclass(add), 是否是类; 
inspect.ismodule(inspect), 是否是模块; 
inspect.isbuiltin(print), 是否是内建函数.
... 
还有很多is函数,需要的时候查阅inspect模块帮助.
```

## parameters 属性 

>   inspect.Signature 对象的 paramerters属性是一个mappingproxy（映射）类型的对象，值为一个有序字典（Orderdict)。
>
>   -   该有序字典里的key为参数名，str类型。
>   -   value是一个inspect.Parameter类型的对象, 这个对象里包含的一个参数的各种信息。 

parameters对象：

-   保存在元组中, 只读。
-   name为参数的名字。
-   annotation, 参数的注解, 可能没有定义。
-   default, 参数的缺省值, 可能没有定义。
-   empty, 特殊的类, 用来标记default属性或者注释annotation属性。
-   kind, 实参如何绑定到形参, 就是形参的类型。
-   POSITIONAL_ONLY, 值必须是位置参数提供。 
-   POSITIONAL_OR_KEYWORD, 值可作为关键字或者位置参数提供。
-   VAR_POSITIONAL, 可变位置参数, 对应*args。
-   KEYWORD_ONLY, keyword-only参数, 对应*或者*args之后出现的非可变关键字参数。
	   VAR_KEYWORD, 可变关键字参数, 对应**kwargs。	

```python 
In [1]: import inspect

In [2]: def add(x:int, y:int, *args, **kwargs) -> int:
   ...:     return x + y
   ...:

In [3]: isg = inspect.signature(add)

In [4]: isg
Out[4]: <Signature (x:int, y:int, *args, **kwargs) -> int>

In [5]: isg.parameters
Out[5]:
mappingproxy({'args': <Parameter "*args">,
              'kwargs': <Parameter "**kwargs">,
              'x': <Parameter "x:int">,
              'y': <Parameter "y:int">})

In [6]: isg.parameters.items()
Out[6]: odict_items([('x', <Parameter "x:int">), ('y', <Parameter "y:int">), ('args', <Parameter "*args">), ('kwargs', <Parameter "**kwargs">)])

In [7]: for i, item in enumerate(isg.parameters.items()):
   ...:     name, param = item
   ...:     print('name: {}, param: {}'.format(name, param))
   ...:     print(param.annotation, param.kind, param.default)
   ...:     print(param.default is param.empty)
   ...:
name: x, param: x:int
<class 'int'> POSITIONAL_OR_KEYWORD <class 'inspect._empty'>
True

name: y, param: y:int
<class 'int'> POSITIONAL_OR_KEYWORD <class 'inspect._empty'>
True

name: args, param: *args
<class 'inspect._empty'> VAR_POSITIONAL <class 'inspect._empty'>
True

name: kwargs, param: **kwargs
<class 'inspect._empty'> VAR_KEYWORD <class 'inspect._empty'>
True

In [8]:
```

示例：业务应用

[**示例代码**](https://github.com/amesy/PythonStudyNotes/blob/master/%E4%BB%A3%E7%A0%81/partial/%E4%B8%9A%E5%8A%A1%E5%BA%94%E7%94%A8.py) 

示例：函数动态类型检查

**[示例代码](https://github.com/amesy/PythonStudyNotes/blob/master/%E4%BB%A3%E7%A0%81/partial/%E5%87%BD%E6%95%B0%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.py)**

# 文件操作 

## 复习 - 冯诺伊曼计算机体系结构 

 ![](http://h.hiphotos.baidu.com/baike/pic/item/a8773912b31bb051973f1da5367adab44aede020.jpg)

>   CPU由控制器和运算器组成。
>
>   -   运算器: 完成各种算数运算,逻辑运算,数据传输等数据加工处理。
>   -   控制器: 控制程序的执行。
>   -   存储器: 用于记忆程序和数据,例如内存等。
>   -   输入设备: 将数据或者程序输入到计算机中,例如键盘,鼠标等。
>   -   输出设备: 将数据或程序的处理结果展示给用户,例如显示器,打印机等。
>
>   一般的IO操作, 指文件IO, 如果指的是网络IO,都会直接说网络IO。

## 文件操作  

**文件IO常用操作:** 

>   open, read, readline, readlines, write, close, flush, next, tell, seek, writelines

**打开操作:** 

>   open(file, mode='r', buffering=-1, encoding=None, newline=None, closefd=True, opener=None) 
>
>   打开文件的模式有：
>
>   -   只读模式（默认）
>   -   只写模式（不可读，不存在则创建，存在则覆盖）
>   -   追加模式（可读，不存在则创建,存在则只追加内容）
>
>   mode模式： 
>
>   -   r : 缺省, 表示只读打开, 文件不存在或使用write方法, 会抛异常。
>   -   w : 只写打开, 读取则抛异常, 文件不存在则创建, 反之清空文件内容。
>   -   x : 创建并写入一个新文件, 以只读方式打开, 文件存在则抛异常。
>   -   a : 写入打开,文件存在则追加。
>
>
>
>   -   r+：可读写，与a+的区别是可以写到文件任何位置。
>
>   -   a+：可读写模式，写只能写在文件末尾。
>
>   -   w+：可读写，与a+的区别是要清空文件内容。
>
>       ​
>
>   -   b：二进制模式; 将文件按字节理解,与字符编码无关,二进制模式操作时,字节操作使用bytes类型。 
>
>   -   rb：二进制文件。
>
>   -   wb：二进制写, 文件存储同样被清空。
>
>       ​
>
>   -   t：缺省的,文本模式,字符流,将文件字节按某种字符编码理解,按字符操作,open的默认mode是rt。  
>
>   -   +：读写打开一个文件, 给原来只读,只写文件打开提供缺失的读或写的功能,不能单独使用。 
>
>   -   w 或 wt：文本模式写，打开前文件存储被清空。 

**读操作:**

>-   read(size = -1)   size表示读取的多少个字符或字节; 负数或者None表示读取到EOF。 
>-   readline(size = -1)   行读取,  size设置一次能读取行内几个字符或字节; 
>
>
>-   readlines(hint = -1)   多行读取, 读取所有行的列表, 指定 hint 则返回指定的行数。

**文件指针操作：** 

>   -   mode=r, 指针起始在0。 
>
>   -   mode=a, 指针起始在EOF。 
>
>   -   tell(), 显示指针当前位置。 
>
>   -   seek(offset[, whence]) , 文件指针操作。
>
>       移动文件指针位置. offset偏移多少字节, whence从哪里开始。 
>
>       **文本模式下:** 
>
>       -   whence 0 缺省值,表示从头开始, offset只能是正整数. 
>       -   whence 1 表示从当前位置, offset只接受0. 
>       -   whence 2 表示从EOF开始,offset只接受0. 
>
>       **二进制模式下:**
>
>       -   whence 0 缺省值, 表示从头开始, offset只能是正整数。 
>
>       -   whence 1 表示从当前位置, offset可正可负。 
>
>       -   whence 2 表示从EOF开始, offset可正可负。 
>
>           二进制模式支持任意起点的偏移, 从头、从尾、从中间位置开始。
>
>           向后seek可以超界,但是向前seek的时候, 不能超界, 否则抛异常。 

**写操作：** 

>   write()
>
>   -   write(s), 把字符串s写入到文件中并返回字符的个数。

**刷新操作:** 

>   flush()
>
>   -   将文件写入到硬盘。

**关闭操作: ** 

>   close()
>
>   -   flush 并关闭文件对象。 
>
>       文件已经关闭, 再次关闭没有任何效果。

**其他:** 

>   -   seekable(), 是否可seek。 
>   -   readable(), 是否可读写。 
>   -   writeable(), 是否可写。 
>   -   closed(), 是否已经关闭。

**buffering: 缓冲区** 

>    缓冲区一个内存空间,一般来说是一个 FIFO 队列,到缓冲区满了或达到阈值,数据才会 flush 到磁盘。

-   -1  表示使用缺省大小的buffer。如果是二进制模式,使用 `io.DEFAULT_BUFFER_SIZE` 值,默认是 4096 或者 8192。如果是文本模式/终端设备,则是行缓存方式, 反之则使用二进制模式策略。 
-   0  只在二进制模式使用,表示关buffer。
-   1  只在文本模式使用,表示使用行缓冲,意思是见到换行符就flush。
-   大于1用于指定buffer的大小。

总结: 

-   文本模式,一般都用默认缓冲区大小。
-   二进制模式,是一个个字节的操作,可以指定buffer的大小。 
-   一般,默认缓冲区大小是个比较好的选择,除非明确知道,否则不调用它。
-   一般编程中,明确知道需要写磁盘了,都会手动调用一次flush,而不是等到自动flush或者close的时候。

**encoding: 编码** 

>   encoding:编码, 仅文本模式使用。 
>
>   encoding表示的是返回的数据采用何种编码，一般采用utf8或者gbk。 
>
>   Nome表示使用缺省编码,依赖操作系统. 

**其他参数:** 

>   errors: 什么样的编码错误将被捕获. None和strict表示有编码错误将抛出ValueError异常; ignore表示忽略. 

>   newline: 文本模式中,换行的转换. 可以为None, '', '\r', '\n', '\r\n'.  
>
>   -   读时, None表示'\r', '\n', '\r\n'都会被转换成'\n'; ''表示不会自动转换通用换行符;其他合法字符表示换行符就是指定字符,就会按照指定字符分行；
>   -   写时, None表示'\n'都会被替换为系统缺省分隔符os.sleep; '\n'或表示'\n'不替换; 其他合法字符表示'\n'会被替换为指定的字符。  
>
>   closefd: 关闭文件描述符,True表示关闭它, False会在文件关闭后保持这个描述符。

## 上下文管理 

>   一种特殊的语法, 交给解释器去释放文件对象。 
>
>    使用with ... as关键字。  
>
>   -   上下文管理的语句并不会开启新的作用域。 
>   -   with语句执行完时, 会自动关闭文件对象。

示例：其他写法 

```python 
In [1]: f1 = open('test.txt')

In [2]: with f1:
   ...:     f1.write('abc')  # 文件只读, 写入失败。 
   ...:
---------------------------------------------------------------------------
UnsupportedOperation                      Traceback (most recent call last)
<ipython-input-2-b470ec0ee3f2> in <module>()
      1 with f1:
----> 2     f1.write('abc')
      3

UnsupportedOperation: not writable

In [3]: f1.closed  # 此时，测试发现，文件已经关闭。
Out[3]: True

In [4]:
```

对于类似于文件对象的IO对象, 一般来说都需要在不使用时关闭、注销以释放资源。IO被打开时, 会获得一个文件描述符。计算机资源有限, 所以操作系统都会做限制。

为了保护计算机的资源不被完全耗尽, 计算资源是共享的, 非独占。一般情况下, 除非特别明确知道资源情况, 否则不建议提高资源的限制值来解决此类问题。

## StringIO和BytesIO

**StringIO：**  

>   IO 模块中的类: `from io import StringIO ` 。
>
>   内存中, 开辟一个文本模式的buffer, 可以像文件对象一样操作它。
>
>   当close方法被调用时,这个buffer会被释放。 
>
>   **StringIO操作:**   
>
>   -   getvalue()  获取全部内容, 跟文件指针没有关系。 
>
>   **StringIO的好处:** 
>
>   -   一般磁盘操作比内存操作要慢很多, 内存足够情况下, 一般优化思路是少落地, 减少磁盘IO的过程, 可以大大提高程序的运行效率。

示例 : 

```python 
In [1]: from io import StringIO

# 内存中构建.
In [2]: f = StringIO()  # 像操作文件对象一样.

In [3]: f.write('hello')
Out[3]: 5

In [4]: f.write(' ')
Out[4]: 1

In [5]:  f.write('world!')
Out[5]: 6

In [6]: f.getvalue()  # 输出全部内容. 
Out[6]: 'hello world!'

In [7]:
```

**BytesIO :**   

>   io模块中的类: `from io import BytesIO`  
>
>   内存中,开辟一个二进制模式的buffer, 可以像文件对象一样操作它。 
>
>   当 close 方法被调用时, 这个 buffer 会被释放。

```python 
In [1]: from io import BytesIO

In [2]: bio = BytesIO()

In [3]: bio.readable(), bio.writable(), bio.seekable()
Out[3]: (True, True, True)

In [4]: bio.write('学习编程'.encode('utf-8'))
Out[4]: 12

In [5]: bio.getvalue()
Out[5]: b'\xe5\xad\xa6\xe4\xb9\xa0\xe7\xbc\x96\xe7\xa8\x8b'

In [6]:
```

## file-like object 

>    像`open()`函数返回的这种有个`read()`方法的对象，在Python中统称为file-like Object (类文件对象)。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个`read()`方法就行。
>
>   `StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。
>
>   类文件对象,可以像文件对象一样操作。
>
>   socket对象, 输入输出对象(stdin, stdout)都是类文件对象。

```python 
In [1]: from sys import stdout

In [2]: f = stdout

In [3]: type(f)
Out[3]: colorama.ansitowin32.StreamWrapper

In [4]: f.write('python')
python
In [5]:
```

# 路径操作 

>   在 Python3.4 之前的路径操作方式, 使用 os.path 以字符串的方式操作路径。 
>
>   在Python3.4+ 中新增了pathlib 模块来操作路径，完全采用面向对象的编程方式, 在处理配置路径方面简单高效。 

```python 
In [1]: import pathlib

# 创建Path对象，即初始化路径.
In [2]: p = pathlib.Path('/python/test') 
    
In [3]: p.is_dir()  # 判断是否是目录.
Out[3]: True
```

## 创建目录

>   使用到 mkdir 方法。

```python 
In [1]: import pathlib

In [2]: create_dir = pathlib.Path('/python/test/pathlib')  # 生成一个要创建的文件夹对象.
    
In [3]: create_dir.exists()  # 确认目录是否存在.
Out[3]: False

In [4]: create_dir.mkdir(755, parents=True, exist_ok=True)  # 创建一个 pathlib 文件夹，设置文件夹权限为755.

In [5]: pwd
Out[5]: '/python/test'

In [6]: ls -ld  pathlib  # 查看创建的文件信息.
d-wxrw--wt 0 amesy amesy 512 Mar 10 04:27 pathlib/

In [7]:
```

>   相当于 `mkdir -p` , 参数 `parents=True` 表示自动创建父目录，`exist_ok=True`  表示若目录存在则不抛任何错误, 否则抛出FileNotFoundError。 

## 删除目录

>   使用到 rmdir() 方法, 没有提供判断目录为空的方法。

```python 
In [7]: delete_dir = pathlib.Path('./pathlib')  # 生成需要删除的目录对象.

In [8]: delete_dir.rmdir()  # 删除目录，另外rmdir删除目录的话，只能删除空目录.

In [9]: ls -ld pathlib  # 确认目录已经删除.
ls: cannot access 'pathlib': No such file or directory

In [10]:
```

## 路径拼接

>   使用到操作符: '/' .
>
>   -   Path对象/Path对象. 
>   -   Path对象/字符串或者字符串/Path对象. 

```python 
In [1]: import pathlib

In [2]: p = pathlib.Path('a', 'b', 'c/d')  # 要拼接的字符串.

In [3]: p
Out[3]: PosixPath('a/b/c/d')  # 拼接后的结果.

In [4]:
```

**windows下的路径拼接**

>   注意用 print 打印, 输出结果中的路径才是反斜杠。

```python 
In [1]: import pathlib

In [2]: pathlib.PureWindowsPath('c:', 'windows', 'system32')
Out[2]: PureWindowsPath('c:windows/system32')

In [3]: print(pathlib.PureWindowsPath('c:','windows','system32'))
c:windows\system32

In [4]:
```
## 路径分解

>   使用到 parts 属性, 可以返回路径中的每一个部分。 
>

```python 
In [4]: p = pathlib.Path() / 'a'   # pathlib.Path() 等同于 p = Path('.'）.

In [5]: p
Out[5]: PosixPath('a')

In [6]: p1 = 'b' / p

In [7]: p1
Out[7]: PosixPath('b/a')

In [8]: p2 = pathlib.Path('c') / p1

In [9]: p2
Out[9]: PosixPath('c/b/a')

In [10]: p2.parts
Out[10]: ('c', 'b', 'a')

In [11]:
```

## 字符串与path对象拼接

>   使用到 joinpath 方法。 
>
>   -   joinpath(*other)    # 连接多个字符串到Path对象中。 

```python 
In [11]: p2
Out[11]: PosixPath('c/b/a')

In [12]: p2.joinpath('etc/', 'init.d/', pathlib.Path('mysqld'))  # 注意左斜杠.
Out[12]: PosixPath('c/b/a/etc/init.d/mysqld')

In [13]:
```

## 获取路径

>   str  获取路径字符串。
>
>   bytes  获取路径字符串的bytes。

```python 
In [13]: p = pathlib.Path('/usr/local')

In [14]: str(p), bytes(p)
Out[14]: ('/usr/local', b'/usr/local')

In [15]:
```

## 父目录  

>   parent  目录的逻辑父目录。 
>
>   parents  父目录序列。 

```python 
In [15]: p = pathlib.Path('/a/b/c/d/')

In [16]: p
Out[16]: PosixPath('/a/b/c/d')

In [17]: p.parent
Out[17]: PosixPath('/a/b/c')

In [18]: p.parent.parent
Out[18]: PosixPath('/a/b')

In [19]: p.parent.parent.parent
Out[19]: PosixPath('/a')

In [20]: [x for x in p.parents]
Out[20]: [PosixPath('/a/b/c'), PosixPath('/a/b'), PosixPath('/a'), PosixPath('/')]

In [21]:
```

## 其他属性

>   name  返回目录的最后一个部分。
>
>   suffix  返回目录中最后一个部分的扩展名。
>
>   stem  返回目录最后一个部分,没有后缀。
>
>   cwd()  返回当前工作目录。 
>
>   home()  返回当前家目录。 
>
>   touch(mode=0o666, exist_ok=True)   创建一个文件。
>
>   as_uri()  将路径返回成URI, 例如 'file:///etc/passwd' 。 
>
>   iterdit()  迭代当前目录。 
>
>   resolve()  返回一个新的路径, 这个新路径就是当前Path对象的绝对路径,如果是软链接则直接被解析。 
>
>   absolute()  也可以获取绝对路径,但是推荐使用resolve()。
>
>   suffixes  返回多个扩展名列表。
>
>   with_suffix(suffix)  补充扩展名到路径尾部,返回新的路径,扩展名存在则无效。
>
>   with_name(name)  替换目录最后一个部分并返回一个新的路径，不改变原路径。

```python 
In [21]: p.name
Out[21]: 'mysql.tar.gz'

In [22]: p.suffix
Out[22]: '.gz'

In [23]: p.suffixes
Out[23]: ['.tar', '.gz']

In [24]: p.stem
Out[24]: 'mysql.tar'

In [25]: p.with_name('mysql-5.tar')
Out[25]: PosixPath('/etc/mysqlinstall/mysql-5.tar')

In [26]: p.with_suffix('.gz')
Out[26]: PosixPath('/etc/mysqlinstall/mysql.tar.gz')

In [27]: p
Out[27]: PosixPath('/etc/mysqlinstall/mysql.tar.gz')

In [34]:
```

## 一些判断的方法

>   is_dir()   是否是目录; 
>
>   is_file()   是否是普通文件; 
>
>   is_symlink()   是否是软链接; 
>
>   is_socket()  是否是socket文件; 
>
>   is_block_device()  是否是块设备; 
>
>   is_char_device()   是否是字符设备; 
>
>   is_absolute()   是否是绝对路径; 
>
>   exists()   目录或文件是否存在. 

## 通配符

>   glob(pattern)   通配给定的模式。 
>
>   rglob(pattern)   通配给定的模式,递归目录。 

```python 
In [1]: import pathlib

In [2]: p = pathlib.Path()

In [3]: list(p.glob('test'))
Out[3]: []

In [4]: list(p.glob('*.py'))
Out[4]: [PosixPath('test.py')]

In [5]: list(p.glob('**/.*.py'))
Out[5]: []
```

## 匹配模式

>   match(pattern)   模式匹配,成功返回True。

```python 
In [6]: pathlib.Path('/a/b/c.py').match('b/*.py')
Out[6]: True

In [7]: pathlib.Path('/a/b/c.py').match('a/*.py')
Out[7]: False
```

## 文件操作

>   open(mode='r', buffering=-1, ending=None, errors=None, newline=None) 
>
>   使用方法类似内建函数open(), 返回一个文件对象。 
>
>   以下为 python3.5以后增加的新函数:  
>
>   -   `read_bytes()`
>
>       以 'rb' 读取路径对应文件,并返回二进制流. 具体可通过看源码知悉。 
>
>   -   `read_text(encoding=None, errors=None)`
>
>       以 'rt' 方式读取路径对应文件,返回文本。
>
>   -   `Path.write_bytes(data) `
>
>       以 'wb' 方式写入数据到路径对应文件。
>
>   -   `write_text(data, encoding=None, errors=None) `
>
>       以 'wt' 方式写入字符串到路径对应文件。

```python 
# read_bytes()
In [1]: import pathlib

In [2]: p = pathlib.Path('my_binary_file')

In [3]: p.write_bytes(b'Binary file contents')
Out[3]: 20

In [4]: p.read_bytes()
Out[4]: b'Binary file contents'

# read_text()    
In [5]: p = pathlib.Path('my_text_file')

In [6]: p.write_text('Text file contents')
Out[6]: 18

In [7]: p.read_text()
Out[7]: 'Text file contents'

# 写入文件内.
In [8]: p = pathlib.Path(r'/python/test/config.py')  # config.py文件的父目录要存在,否则会报错.

In [9]: p.write_text('hello python')
Out[9]: 12

In [10]: p.read_text()
Out[10]: 'hello python'

In [11]: with p.open() as f:
    ...:     print(f.read(5))
    ...:
hello

In [12]:
```

# os 模块 

>   **os.name**    windows是nt, linux是posix。
>
>   **os.uname()**	 Linux支持显示。 
>
>   **sys.platform**    windows显示win32, linux显示linux。  
>
>   **os.listdir('o:/temp')**    返回目录内容文件。 
>
>   os 也有 open, read, write 等方法, 但太低级,建议使用内建函数 open, read, write.  
>
>   **os.stat(path, *, dir_fd=None, follow_symlinks=True) ** 
>
>   -   调用linux系统的 stat 。 
>   -   path:  路径的string或者bytes, 后者fd。 
>   -   follow_symlinks True   返回文件本身信息, False且如果是软链接则显示软链接本身。 
>
>   **os.chown(path, uid, gid)**    改变文件的属主, 属组, 但需要足够的权限。 

```python 
In [1]: import os, sys

In [2]: os.name
Out[2]: 'posix'

In [3]: os.uname()
Out[3]: posix.uname_result(sysname='Linux', nodename='AMESY-PC', release='4.4.0-43-Microsoft', version='#1-Microsoft Wed Dec 31 14:42:53 PST 2014', machine='x86_64')

In [4]: sys.platform
Out[4]: 'linux'

In [5]: os.listdir('/python/test')
Out[5]: ['.python-version', 'config.py', 'my_binary_file', 'my_text_file', 'test.py']

In [6]: os.stat('/python/test/config.py')
Out[6]: os.stat_result(st_mode=33206, st_ino=15199648742690179, st_dev=2, st_nlink=1, st_uid=1000, st_gid=1000, st_size=12, st_atime=1520664200, st_mtime=1520664200, st_ctime=1520664200)

In [7]:
```

# shutil 模块  

目前为止, 文件的拷贝通过打开文件对象、读取源文件内容、写入目标文件中来完成拷贝过程, 但这样会丢失 stat 数据信息(权限等), 因为根本就没复制过去。此时 python 提供了一个方便的库 shutil 来操作复杂的文件或者目录。

## copy 复制 

>   `copyfileobj(fsrc, fdst[, length]) ` 
>
>   -   文件对象的复制, fsrc 和 fdst 是 open 打开的文件对象,复制内容, fdst要求可写。 
>   -   length指定了表示buffer的大小。 
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: with open('/python/test/one.txt', 'r+') as f:
>      ...:     f.write('abcd\n1234\n')
>      ...:     f.seek(0)
>      ...:     f.flush()
>      ...:     with open('/python/test/two.txt', 'w+') as f1:
>      ...:         shutil.copyfileobj(f, f1)  # 将文件f的内容复制到文件f1
>      ...:									# 使用 stat 命令可以看到, 将文件f的全部信息一同复制给了文件f1.
>
>   In [3]:
>   ```
>
>   `copyfile(src, dst, *, follow_symlinks=True)`
>
>   -   复制文件内容,不含元数据; src, dst为文件的路径字符串。
>   -   本质上调用的就是coppyfileobj, 所以不带元数据二进制内容复制。
>
>   `copymode(src,dst,*,follow_symlinks=True)`   
>
>   -   仅仅复制权限. 
>
>   `copystat(src, dst, *, follow_symlinks=True)`  
>
>   -   复制元数据,stat包含权限. 
>
>   `copy(src, dst, *, follow_symlinks=True) `  
>
>   -   复制文件内容,权限和部分元数据,不包括创建时间和修改时间。
>   -   本质上调用的是: 
>       -   copyfile(src, dst, follow_symlinks=follow_symlinks)  
>       -   copymode(src, dst, follow_symlinks=follow_symlinks) 
>   -   copy2() 比 copy() 多了复制全部元数据,但需要平台支持。
>       -   本质上调用的是:  
>           -   copyfile(src, dst, follow_symlinks=follow_symlinks) 
>           -   copystat(src, dst, follow_symlinks=follow_symlinks) 
>
>   `copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False) `
>
>   -   递归复制目录. 默认使用copy2, 也就是带更多的元数据复制。
>   -   src, dst必须是目录, src必须存在, dst必须不存在。 
>   -   ignore=func, 提供一个callable(src, names)  -> ignore_names. 提供一个函数, 它会被调用. src是源目录, names是os.listdir(src)的结果, 就是列出src中的文件名, 返回值是要被过滤的文件名的set类型数据。

## rm 删除 

>   `shutil.rmtree(path, ignore_errors=False, onerror=None)  ` 
>
>   -   递归删除一个目录以及目录内的所有内容, 如同 rm -rf 命令一样危险, 慎用。 
>   -   它不是原子操作, 有可能删除错误, 就会中断,已经删除的就删除了。
>   -   ignore_errors为true,忽略错误. 当为False或omitted时, onerror生效。 
>   -   onerror为callable,接受函数function, path和execinfo. 
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: ls dir
>   module.py
>
>   In [3]: shutil.rmtree('dir')  
>
>   In [4]: ls dir
>   ls: cannot access 'dir': No such file or directory
>
>   In [5]:
>   ```

## move 移动 

>   `move(src, dst, copy_function=copy2)` 
>
>   -   递归移动文件/目录到目标, 返回目标。 
>   -   本身使用的是 os.rename 方法。 
>   -   如果不支持 rename, 如果是目录则要先 copytree 再删除源目录。 
>   -   默认使用copy2方法。
>
>   ```python 
>   In [1]: import shutil
>
>   In [2]: shutil.move('one.txt', 'first.txt')
>   Out[2]: 'first.txt'
>
>   In [3]:
>   ```

**shutil 还支持打包功能, 生成tar并压缩, 支持zip,gz,bz,xz**。

# 序列化和反序列化 

>   为什么要序列化?
>
>   -   内存中的字典/链表如何保存到一个文件中? 
>   -   如果是自己定义的类的实例,如何保存到一个文件中? 
>   -   如何从文件中读取数据,并让它们在内存中再次变成自己对应的类的实例? 
>
>   内存中的数据要永久存储下来，就要保存到文件中，而文件是一个字节序列。 
>
>   **序列化：** 把数据从内存中变成可存储或传输的过程。 
>
>   **反序列化：**把数据从序列化的对象重新读到内存里的过程。
>
>   序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
>
>   Python提供了 `pickle` 模块来实现序列化和反序列化。 

## pickle

>   `dumps(obj, protocol=None, *, fix_imports=True) `
>
>   -   对象序列化。 
>
>   `dump(obj, file, protocol=None, *, fix_imports=True)`
>
>   -   将对象序列化到文件对象, 即存入文件。
>
>   `loads(data, *, fix_imports=True, encoding='ASCII', errors='strict') `
>
>   -   对象反序列化。
>
>   `load(file, *, fix_imports=True, encoding='ASCII', errors='strict')` 
>
>   -   将对象反序列化, 即从文件读取数据。

```python
In [1]: import pickle

In [2]: file = '/python/test/one.txt'

In [3]: with open(file, 'wb') as f:
   ...:     s1 = 99
   ...:     s2 = 'abc'
   ...:     s3 = ['a', 'b', ['c', 'd']]
   ...:     pickle.dump(s1, f)
   ...:     pickle.dump(s2, f)
   ...:     pickle.dump(s3, f)
   ...:

In [4]: with open(file, 'rb') as f:
   ...:     s = [pickle.load(f) for _ in range(3)]
   ...:     print(s)
   ...:
[99, 'abc', ['a', 'b', ['c', 'd']]]

In [5]:
```

示例：

```python 
In [1]: import pickle

# 对象序列化.    
In [2]: class Pickle:
   ...:     words = 'ABCD'
   ...:     def show(self):
   ...:         print('abcd')
   ...:

In [3]: res1 = Pickle()

In [4]: sr = pickle.dumps(res1)

In [5]: res2 = pickle.loads(sr)

In [6]: res2.show()
abcd

In [7]:
```

上面例子中，其实只保存了一个类名，因为所有其他东西都是类定义的东西, 是不变的, 所以只序列化一个Pickle类名，反序列化时找到类就可以恢复一个对象。如果是保存了类Pickle()，则反序列化时要找到Pickle类的定义，才能成功，否则就会抛异常。 

示例：pickle 序列化的应用 .

>   本地序列化的情况应用较少，大多数场景都应用在网络中。将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接收到的数据进行反序列化后就可以使用了。
>
>   注意，远程接收端反序列化时必须有对应的数据类型，否则就会报错，尤其是定义类，必须远程得有。 

```python 
# 第一台节点服务器
In [1]: import pickle

In [2]: class AA:
   ...:     def __init__(self):
   ...:         self.name = 'amesy'

In [3]: res = AA()

In [4]: sr = pickle.dumps(res)

In [5]: file = '/python/test/pickle.txt'

In [6]: with open(file, 'wb') as f:
   ...:     pickle.dump(res, f)
   ...:

In [7]:
```

```python 
# 第二台节点服务器
# 将上面产生的序列化文件传送到其他节点运行,保证序列化文件是源文件。
In [1]: import pickle 

In [2]: class AA: 
   ...:     def __init__(self): 
   ...:         self.name = 'amesy' 
   ...:         

In [3]: file = '/python/test/pickle.txt' 

In [4]: with open(file, 'rb') as f: 
   ...:     a = pickle.load(f) 
   ...:     

In [5]: a.name
Out[5]: 'amesy'

In [6]: 
```

总结：现在大多数项目都不是单机或单服务, 需要通过网络将数据传送到其他节点上，此时就需要大量的序列化、反序列化。 

但问题是python程序之间还可以只用pickle解决序列化、反序列化问题；如果是跨平台跨语言跨协议, 再用pickle就不太合适了，需要公共的协议，如XML，json，protocol buffer等等。具体情况需要具体选型。

## Json 

>   JSON(JavaScript Object Notation, JS对象标记)是一种轻量级的数据交换格式, 是存储和交换文本信息的语法，类似XML。	
>
>   **Json的数据类型** 
>
>   -   值
>       -   引号引起来的字符串: 数值, string, true, false, null,object, array等,这些都是值。
>   -   字符串
>       -   由双引号包围起来的任意字符的组合,可以有转义字符。
>   -   数值: 
>       -   有正负, 有整数, 浮点数。
>   -   对象: 
>       -   无序的键值对的集合; 
>       -   格式: {key1:value1, ..., keyn:valuen}
>       -   key必须是一个字符串,需要双引号保卫这个字符串; 
>       -   value可以是任意合法的值. 
>   -   数组: 
>       -   有序的值的组合 
>       -   格式: [val1, ..., valn]  

**json模块: **

-   python 和 json : 
    -   python支持少量内置数据类型到json的转换. 
    -   True - true, False - false, None - null, str - string.
    -   int - integer, float - float, list - array, dict - object.  

-   常用方法:
    -   **load**   json解码,从文件读取数据。
    -   **loads**   json 解码。
    -   **dump**   json编码并存入文件。
    -   **dumps**   json编码。

```python 
In [1]: import json

In [2]: d = {'name':'Tom', 'age':20, 'interest':['music','movie']}

In [3]: j = json.dumps(d)

In [4]: j
Out[4]: '{"name": "Tom", "age": 20, "interest": ["music", "movie"]}'

In [5]:

In [5]: d1 = json.loads(j)

In [6]: d1
Out[6]: {'age': 20, 'interest': ['music', 'movie'], 'name': 'Tom'}

In [7]:
```

一般 json 编码的数据很少落地, 数据都是通过网络传输。传输的时候, 要考虑压缩它, 本质上来说它就是个文本, 是个字符串。
json 很简单, 几乎编程语言都支持, 所以应用很广泛。 

## MessagePack 

>   MessagePack是一个基于二进制高效的对象序列化类库, 可用于跨语言通信。它可以像 JSON 一样, 在许多语言之间交换结构数据; 但它比JSON更快更轻巧。支持很多种语言(python，java，ruby，c，golang等)。兼容json和pickle。
>
>   官网: https://msgpack.org/ 
>
>   安装: pip install msgpack-python

常用方法: 

-   **packb**   序列化对象. 提供了dumps来兼容pickle和json。
-   **unpackb**   反序列化对象, 提供了loads来兼容。  
-   **pack**   序列化对象保存到文件对象, 提供了dump来兼容。 
-   **unpack**   反序列化对象保存到文件对象, 提供了load来兼容。

```python 
In [1]: import msgpack

In [2]: d = {"person":[{"name":"tom", "age":18}, {"name":"jerry", "age":16}], "total":2}

In [3]: b = msgpack.packb(d)

In [4]: b
Out[4]: b'\x82\xa6person\x92\x82\xa4name\xa3tom\xa3age\x12\x82\xa4name\xa5jerry\xa3age\x10\xa5total\x02'

In [5]: len(b)
Out[5]: 48

In [6]: d1 = msgpack.unpackb(b, encoding='utf-8')

In [7]: d1
Out[7]:
{'person': [{'age': 18, 'name': 'tom'}, {'age': 16, 'name': 'jerry'}],
 'total': 2}

In [8]:
```

```python 
In [8]: d = [1, 2, 3]

In [9]: res1 = msgpack.packb(d)

In [10]: res1
Out[10]: b'\x93\x01\x02\x03'

In [11]: msgpack.unpackb(res1)
Out[11]: [1, 2, 3]

In [12]: res2 = msgpack.unpackb(res1, use_list=False)

In [13]: res2
Out[13]: (1, 2, 3)

In [17]:
```

**注:** 官方建议始终指定 use_list 关键字参数以实现向后兼容性。

# 面向对象

...



 





